#!/usr/bin/env python3
"""
{{ project_name }} - Data Processing Application
Generated by Copier Template
"""

import pandas as pd
import toml
import os
from pathlib import Path
from typing import Dict, Any, Optional


def load_config() -> Dict[str, Any]:
    """Load configuration from config.toml file."""
    config_path = Path(__file__).parent / "config.toml"
    return toml.load(config_path)


{% for i in range(num_inputs) %}
def load_{{ input_{{ i + 1 }}_identifier }}(file_path: str) -> pd.DataFrame:
    """
    Load {{ input_{{ i + 1 }}_placeholder }} from file.
    
    Args:
        file_path (str): Path to the input file
        
    Returns:
        pd.DataFrame: Loaded data
    """
    config = load_config()
    
    {% if input_{{ i + 1 }}_format == "CSV" %}
    try:
        df = pd.read_csv(file_path)
        print(f"Successfully loaded {{ input_{{ i + 1 }}_placeholder }} from CSV: {file_path}")
        return df
    except Exception as e:
        print(f"Error loading CSV file {file_path}: {e}")
        raise
    {% else %}
    try:
        sheet_name = config['input_formats'].get('{{ input_{{ i + 1 }}_identifier }}_sheet_name', 'Sheet1')
        start_row = config['input_formats'].get('{{ input_{{ i + 1 }}_identifier }}_start_row', 1) - 1  # Convert to 0-based
        
        df = pd.read_excel(
            file_path, 
            sheet_name=sheet_name,
            skiprows=start_row
        )
        
        # Handle start column if specified
        start_col = config['input_formats'].get('{{ input_{{ i + 1 }}_identifier }}_start_col', 1) - 1  # Convert to 0-based
        if start_col > 0:
            df = df.iloc[:, start_col:]
            
        print(f"Successfully loaded {{ input_{{ i + 1 }}_placeholder }} from Excel: {file_path}")
        return df
    except Exception as e:
        print(f"Error loading Excel file {file_path}: {e}")
        raise
    {% endif %}


def process_{{ input_{{ i + 1 }}_identifier }}(df: pd.DataFrame) -> pd.DataFrame:
    """
    Process {{ input_{{ i + 1 }}_placeholder }}.
    
    Args:
        df (pd.DataFrame): Input dataframe
        
    Returns:
        pd.DataFrame: Processed dataframe
    """
    # Add your processing logic here
    print(f"Processing {{ input_{{ i + 1 }}_placeholder }}...")
    
    # Example processing - modify as needed
    processed_df = df.copy()
    
    # Add your custom processing logic here
    # processed_df = processed_df.dropna()
    # processed_df = processed_df.reset_index(drop=True)
    
    print(f"Processed {{ input_{{ i + 1 }}_placeholder }}: {len(processed_df)} rows")
    return processed_df

{% endfor %}

def worker_function({% for i in range(num_inputs) %}{{ input_{{ i + 1 }}_identifier }}_path: str{% if not loop.last %}, {% endif %}{% endfor %}) -> Dict[str, pd.DataFrame]:
    """
    Main worker function that processes all inputs and generates outputs.
    
    Args:
    {% for i in range(num_inputs) %}
        {{ input_{{ i + 1 }}_identifier }}_path (str): Path to {{ input_{{ i + 1 }}_placeholder }}
    {% endfor %}
        
    Returns:
        Dict[str, pd.DataFrame]: Dictionary containing processed data
    """
    results = {}
    
    try:
        # Load and process each input
        {% for i in range(num_inputs) %}
        print(f"Loading {{ input_{{ i + 1 }}_placeholder }}...")
        {{ input_{{ i + 1 }}_identifier }}_data = load_{{ input_{{ i + 1 }}_identifier }}({{ input_{{ i + 1 }}_identifier }}_path)
        {{ input_{{ i + 1 }}_identifier }}_processed = process_{{ input_{{ i + 1 }}_identifier }}({{ input_{{ i + 1 }}_identifier }}_data)
        results['{{ input_{{ i + 1 }}_identifier }}'] = {{ input_{{ i + 1 }}_identifier }}_processed
        
        {% endfor %}
        
        # Combine or further process data as needed
        print("Running main processing logic...")
        
        # Add your main processing logic here that combines/uses the loaded data
        # Example: combined_data = pd.concat([results['input_1'], results['input_2']], ignore_index=True)
        
        {% for i in range(num_outputs) %}
        # Generate output {{ i + 1 }}
        output_{{ i + 1 }}_data = results.get('{{ input_1_identifier }}', pd.DataFrame()).copy()  # Modify as needed
        results['{{ output_{{ i + 1 }}_name }}'] = output_{{ i + 1 }}_data
        
        {% endfor %}
        
        print("Worker function completed successfully!")
        return results
        
    except Exception as e:
        print(f"Error in worker function: {e}")
        raise


def save_outputs(results: Dict[str, pd.DataFrame], output_dir: str = "outputs") -> None:
    """
    Save processed results to output files.
    
    Args:
        results (Dict[str, pd.DataFrame]): Results from worker function
        output_dir (str): Directory to save outputs
    """
    config = load_config()
    
    # Create output directory if it doesn't exist
    Path(output_dir).mkdir(exist_ok=True)
    
    {% for i in range(num_outputs) %}
    # Save {{ output_{{ i + 1 }}_name }}
    if '{{ output_{{ i + 1 }}_name }}' in results:
        output_path = Path(output_dir) / "{{ output_{{ i + 1 }}_name }}.{{ output_{{ i + 1 }}_format.lower() }}"
        
        {% if output_{{ i + 1 }}_format == "CSV" %}
        results['{{ output_{{ i + 1 }}_name }}'].to_csv(output_path, index=False)
        {% else %}
        results['{{ output_{{ i + 1 }}_name }}'].to_excel(output_path, index=False)
        {% endif %}
        
        print(f"Saved {{ output_{{ i + 1 }}_name }} to: {output_path}")
    
    {% endfor %}


def main():
    """Main function for command line usage."""
    # Example usage - modify paths as needed
    {% for i in range(num_inputs) %}
    {{ input_{{ i + 1 }}_identifier }}_path = input("Enter path for {{ input_{{ i + 1 }}_placeholder }}: ")
    {% endfor %}
    
    # Run worker function
    results = worker_function({% for i in range(num_inputs) %}{{ input_{{ i + 1 }}_identifier }}_path{% if not loop.last %}, {% endif %}{% endfor %})
    
    # Save outputs
    save_outputs(results)
    
    print("Processing completed successfully!")


if __name__ == "__main__":
    main()
