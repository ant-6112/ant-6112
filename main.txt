#!/usr/bin/env python3
"""
{{ project_name }} - Data Processing Application
Generated by Copier Template
"""

import pandas as pd
import toml
import os
from pathlib import Path
from typing import Dict, Any, Optional


def load_config() -> Dict[str, Any]:
    """Load configuration from config.toml file."""
    config_path = Path(__file__).parent / "config.toml"
    return toml.load(config_path)


{% for input in inputs_config %}
def load_{{ input.identifier }}(file_path: str) -> pd.DataFrame:
    """
    Load {{ input.placeholder }} from file.

    Args:
        file_path (str): Path to the input file

    Returns:
        pd.DataFrame: Loaded data
    """
    config = load_config()

    {% if input.format == "CSV" %}
    try:
        df = pd.read_csv(file_path)
        print(f"Successfully loaded {{ input.placeholder }} from CSV: {file_path}")
        return df
    except Exception as e:
        print(f"Error loading CSV file {file_path}: {e}")
        raise
    {% else %}
    try:
        sheet_name = config['input_formats'].get('{{ input.identifier }}_sheet_name', 'Sheet1')
        start_row = config['input_formats'].get('{{ input.identifier }}_start_row', 1) - 1  # Convert to 0-based

        df = pd.read_excel(
            file_path,
            sheet_name=sheet_name,
            skiprows=start_row
        )

        # Handle start column if specified
        start_col = config['input_formats'].get('{{ input.identifier }}_start_col', 1) - 1  # Convert to 0-based
        if start_col > 0:
            df = df.iloc[:, start_col:]

        print(f"Successfully loaded {{ input.placeholder }} from Excel: {file_path}")
        return df
    except Exception as e:
        print(f"Error loading Excel file {file_path}: {e}")
        raise
    {% endif %}


def process_{{ input.identifier }}(df: pd.DataFrame) -> pd.DataFrame:
    """
    Process {{ input.placeholder }}.

    Args:
        df (pd.DataFrame): Input dataframe

    Returns:
        pd.DataFrame: Processed dataframe
    """
    # Add your processing logic here
    print(f"Processing {{ input.placeholder }}...")

    # Example processing - modify as needed
    processed_df = df.copy()

    # Add your custom processing logic here
    # processed_df = processed_df.dropna()
    # processed_df = processed_df.reset_index(drop=True)

    print(f"Processed {{ input.placeholder }}: {len(processed_df)} rows")
    return processed_df

{% endfor %}

def worker_function({% for input in inputs_config %}{{ input.identifier }}_path: str{% if not loop.last %}, {% endif %}{% endfor %}) -> Dict[str, pd.DataFrame]:
    """
    Main worker function that processes all inputs and generates outputs.

    Args:
    {% for input in inputs_config %}
        {{ input.identifier }}_path (str): Path to {{ input.placeholder }}
    {% endfor %}

    Returns:
        Dict[str, pd.DataFrame]: Dictionary containing processed data
    """
    results = {}

    try:
        # Load and process each input
        {% for input in inputs_config %}
        print(f"Loading {{ input.placeholder }}...")
        {{ input.identifier }}_data = load_{{ input.identifier }}({{ input.identifier }}_path)
        {{ input.identifier }}_processed = process_{{ input.identifier }}({{ input.identifier }}_data)
        results['{{ input.identifier }}'] = {{ input.identifier }}_processed

        {% endfor %}

        # Combine or further process data as needed
        print("Running main processing logic...")

        # Add your main processing logic here that combines/uses the loaded data
        # Example: combined_data = pd.concat([results['input_1'], results['input_2']], ignore_index=True)

        {% for output in outputs_config %}
        # Generate output {{ loop.index }}
        output_{{ loop.index }}_data = results.get('{{ inputs_config[0].identifier }}', pd.DataFrame()).copy()  # Modify as needed
        results['{{ output.name }}'] = output_{{ loop.index }}_data

        {% endfor %}

        print("Worker function completed successfully!")
        return results

    except Exception as e:
        print(f"Error in worker function: {e}")
        raise


def save_outputs(results: Dict[str, pd.DataFrame], output_dir: str = "outputs") -> None:
    """
    Save processed results to output files.

    Args:
        results (Dict[str, pd.DataFrame]): Results from worker function
        output_dir (str): Directory to save outputs
    """
    config = load_config()

    # Create output directory if it doesn't exist
    Path(output_dir).mkdir(exist_ok=True)

    {% for output in outputs_config %}
    # Save {{ output.name }}
    if '{{ output.name }}' in results:
        output_path = Path(output_dir) / "{{ output.name }}.{{ output.format.lower() }}"

        {% if output.format == "CSV" %}
        results['{{ output.name }}'].to_csv(output_path, index=False)
        {% else %}
        results['{{ output.name }}'].to_excel(output_path, index=False)
        {% endif %}

        print(f"Saved {{ output.name }} to: {output_path}")

    {% endfor %}


def main():
    """Main function for command line usage."""
    # Example usage - modify paths as needed
    {% for input in inputs_config %}
    {{ input.identifier }}_path = input("Enter path for {{ input.placeholder }}: ")
    {% endfor %}

    # Run worker function
    results = worker_function({% for input in inputs_config %}{{ input.identifier }}_path{% if not loop.last %}, {% endif %}{% endfor %})

    # Save outputs
    save_outputs(results)

    print("Processing completed successfully!")


if __name__ == "__main__":
    main()
